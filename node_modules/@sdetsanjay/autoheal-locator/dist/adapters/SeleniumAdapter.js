"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeleniumAdapter = void 0;
const AutomationFramework_1 = require("../models/AutomationFramework");
/**
 * Selenium WebDriver adapter implementation for JavaScript/TypeScript
 */
class SeleniumAdapter {
    constructor(driver) {
        this.driver = driver;
    }
    getFrameworkType() {
        return AutomationFramework_1.AutomationFramework.SELENIUM;
    }
    async findElements(selector) {
        try {
            const by = this.autoDetectBy(selector);
            const elements = await this.driver.findElements(by);
            return elements;
        }
        catch (error) {
            console.debug(`Failed to find elements with selector: ${selector}`, error);
            return [];
        }
    }
    /**
     * Auto-detect the By locator type from selector string
     */
    autoDetectBy(selector) {
        // Lazy import to avoid circular dependency
        const { By: SeleniumBy } = require('selenium-webdriver');
        // XPath detection
        if (selector.startsWith('/') || selector.startsWith('(')) {
            return SeleniumBy.xpath(selector);
        }
        // CSS selector patterns
        if (selector.startsWith('#')) {
            return SeleniumBy.css(selector);
        }
        if (selector.startsWith('.')) {
            return SeleniumBy.css(selector);
        }
        if (selector.includes('[') || selector.includes('>') || selector.includes('+')) {
            return SeleniumBy.css(selector);
        }
        // Try as ID first (most common)
        if (!/[\s\.\[\]#>+~]/.test(selector)) {
            return SeleniumBy.id(selector);
        }
        // Default to CSS selector
        return SeleniumBy.css(selector);
    }
    async getPageSource() {
        return await this.driver.getPageSource();
    }
    async takeScreenshot() {
        const base64Screenshot = await this.driver.takeScreenshot();
        return Buffer.from(base64Screenshot, 'base64');
    }
    async getCurrentUrl() {
        return await this.driver.getCurrentUrl();
    }
    async getElementContext(element) {
        try {
            // Get element properties
            const tagName = await element.getTagName();
            const id = await element.getAttribute('id');
            const className = await element.getAttribute('class');
            const text = await element.getText();
            // Get element rectangle for position
            const rect = await element.getRect();
            const position = {
                x: Math.round(rect.x),
                y: Math.round(rect.y),
                width: Math.round(rect.width),
                height: Math.round(rect.height),
            };
            // Extract common attributes
            const attributes = {};
            const commonAttrs = ['id', 'class', 'name', 'type', 'value', 'href', 'src', 'data-testid'];
            for (const attr of commonAttrs) {
                const value = await element.getAttribute(attr);
                if (value) {
                    attributes[attr] = value;
                }
            }
            // Get parent container using JavaScript executor
            const parentContainer = await this.driver.executeScript(`
        const el = arguments[0];
        const parent = el.parentElement;
        if (!parent) return 'unknown';
        const parentClass = parent.className ? '.' + parent.className.split(' ')[0] : '';
        const parentId = parent.id ? '#' + parent.id : '';
        return parent.tagName.toLowerCase() + parentId + parentClass;
      `, element);
            // Get sibling elements
            const siblingElements = await this.driver.executeScript(`
        const el = arguments[0];
        const siblings = Array.from(el.parentElement?.children || []);
        return siblings.slice(0, 5).map(sib => sib.tagName.toLowerCase());
      `, element);
            return {
                element,
                fingerprint: {
                    tagName,
                    id: id || undefined,
                    className: className || undefined,
                    text: text || undefined,
                    position,
                    parentContainer,
                    siblingElements,
                },
                pageUrl: await this.getCurrentUrl(),
                parentContainer,
                relativePosition: position,
                siblingElements,
                attributes,
                textContent: text || undefined,
            };
        }
        catch (error) {
            throw new Error(`Failed to extract element context: ${error}`);
        }
    }
    /**
     * Get the Selenium WebDriver instance
     */
    getDriver() {
        return this.driver;
    }
}
exports.SeleniumAdapter = SeleniumAdapter;
//# sourceMappingURL=SeleniumAdapter.js.map