"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryCache = void 0;
const lru_cache_1 = require("lru-cache");
/**
 * In-memory LRU cache implementation
 */
class MemoryCache {
    constructor(maxSize = 1000, ttlMs = 24 * 60 * 60 * 1000) {
        this.hitCount = 0;
        this.missCount = 0;
        this.evictionCount = 0;
        this.cache = new lru_cache_1.LRUCache({
            max: maxSize,
            ttl: ttlMs,
            updateAgeOnGet: true,
            dispose: () => {
                this.evictionCount++;
            },
        });
    }
    get(key) {
        const value = this.cache.get(key);
        if (value) {
            this.hitCount++;
            return value;
        }
        else {
            this.missCount++;
            return undefined;
        }
    }
    put(key, selector) {
        this.cache.set(key, selector);
    }
    remove(key) {
        return this.cache.delete(key);
    }
    clearAll() {
        this.cache.clear();
        this.hitCount = 0;
        this.missCount = 0;
        this.evictionCount = 0;
    }
    size() {
        return this.cache.size;
    }
    updateSuccess(key, success) {
        const cached = this.cache.get(key);
        if (cached) {
            cached.updateSuccess(success);
            this.cache.set(key, cached);
        }
    }
    evictExpired() {
        // LRU cache handles expiration automatically
        this.cache.purgeStale();
    }
    getMetrics() {
        const total = this.hitCount + this.missCount;
        return {
            hitCount: this.hitCount,
            missCount: this.missCount,
            hitRate: total === 0 ? 0 : this.hitCount / total,
            totalEntries: this.cache.size,
            evictionCount: this.evictionCount,
        };
    }
}
exports.MemoryCache = MemoryCache;
//# sourceMappingURL=MemoryCache.js.map